// Copyright 2023 Vincent Free
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package otelmiddleware

import (
	"go.opentelemetry.io/otel/codes"
	"net/http"
	"regexp"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	semconv "go.opentelemetry.io/otel/semconv/v1.11.0"
	"go.opentelemetry.io/otel/trace"
)

// version is used as the instrumentation version.
const version = "0.1.0"

// TraceOption takes a traceConfig struct and applies changes.
// It can be passed to the TraceWithOptions function to configure a traceConfig struct.
type TraceOption func(*traceConfig)

// skipPaths is a slice of pointers to regular expression objects, used to skip specific paths during tracing.
// It is used to exclude certain paths from being traced.
type skipPaths []*regexp.Regexp

func (s skipPaths) shouldSkip(path string) bool {
	for _, re := range s {
		if re.MatchString(path) {
			return true
		}
	}
	return false
}

// traceConfig contains all the configuration for the library.
type traceConfig struct {
	serviceName string
	tracer      trace.Tracer
	propagator  propagation.TextMapPropagator
	attributes  []attribute.KeyValue
	skipPaths   skipPaths
}

// New takes TraceOption's and initializes a new trace.Span.
func New(options ...TraceOption) func(http.Handler) http.Handler {
	return TraceWithOptions(options...)
}

// TraceWithOptions takes TraceOption's and initializes a new trace.Span.
// Deprecated: use New instead
func TraceWithOptions(opt ...TraceOption) func(next http.Handler) http.Handler {
	// initialize an empty traceConfig.
	config := &traceConfig{}

	// apply the configuration passed to the function.
	for _, o := range opt {
		o(config)
	}
	// check for the traceConfig.tracer if absent use a default value.
	if config.tracer == nil {
		config.tracer = otel.Tracer("github.com/vincentfree/opentelemetry/otelmiddleware", trace.WithInstrumentationVersion(version))
	}
	// check for the traceConfig.propagator if absent use a default value.
	if config.propagator == nil {
		config.propagator = otel.GetTextMapPropagator()
	}
	// check for the traceConfig.serviceName if absent use a default value.
	if config.serviceName == "" {
		config.serviceName = "TracedApplication"
	}
	// the handler that initializes the trace.Span.
	return func(next http.Handler) http.Handler {

		// assign the handler which creates the OpenTelemetry trace.Span.
		fn := func(w http.ResponseWriter, r *http.Request) {
			// if the path matches a skip pattern, short circuit
			if config.skipPaths.shouldSkip(r.URL.Path) {
				next.ServeHTTP(w, r)
				return
			}

			requestCtx := r.Context()
			// extract the OpenTelemetry span context from the context.Context object.
			ctx := config.propagator.Extract(requestCtx, propagation.HeaderCarrier(r.Header))
			// the standard trace.SpanStartOption options whom are applied to every server handler.
			opts := []trace.SpanStartOption{

				trace.WithAttributes(semconv.NetAttributesFromHTTPRequest("tcp", r)...),
				trace.WithAttributes(semconv.EndUserAttributesFromHTTPRequest(r)...),
				trace.WithAttributes(semconv.HTTPServerAttributesFromHTTPRequest(r.Host, extractRoute(r.RequestURI), r)...),
				trace.WithAttributes(semconv.HTTPClientAttributesFromHTTPRequest(r)...),
				trace.WithAttributes(semconv.TelemetrySDKLanguageGo),
				trace.WithSpanKind(trace.SpanKindServer),
			}
			// check for the traceConfig.attributes if present, apply them to the trace.Span.
			if len(config.attributes) > 0 {
				opts = append(opts, trace.WithAttributes(config.attributes...))
			}
			// extract the route name which is used for setting a usable name of the span.
			spanName := extractRoute(r.RequestURI)
			if spanName == "" {
				// no path available
				spanName = r.Proto + " " + r.Method + " /"
			}

			// create a good name to recognize where the span originated.
			spanName = r.Method + " /" + spanName

			// start the actual trace.Span.
			ctx, span := config.tracer.Start(ctx, spanName, opts...)

			defer span.End()

			// pass the span through the request context.
			r = r.WithContext(ctx)
			carrier := propagation.HeaderCarrier(r.Header)
			otel.GetTextMapPropagator().Inject(ctx, carrier)

			// use a wrapper for the http.responseWriter to capture the response status code;
			// this information is added to the spans generated by the middleware
			wrapperRes := NewWrapResponseWriter(w, r.ProtoMajor)

			// serve the request to the next middleware.
			next.ServeHTTP(wrapperRes, r)
			// add the response status code to the span
			if span.IsRecording() {
				statusCode := wrapperRes.Status()
				span.SetAttributes(semconv.HTTPAttributesFromHTTPStatusCode(statusCode)...)
				if statusCode >= 500 {
					span.SetStatus(codes.Error, http.StatusText(statusCode))
				}
			}
		}

		return http.HandlerFunc(fn)
	}
}

// Trace uses New without additional options, this is a shorthand for New().
//
// Prefer using the New function with at least the WithServiceName option to set the correct service name.
func Trace(next http.Handler) http.Handler {
	return New()(next)
}

// TraceWithName creates a new trace.Span with the given name and initializes the trace configuration using the
// WithServiceName option.
// It then returns an http.Handler that wraps the next handler and creates the trace.Span
// for each incoming request.
//
// Parameters:
//   - name: The name of the trace.Span.
//   - next: The next http.Handler to be served.
func TraceWithName(name string, next http.Handler) http.Handler {
	return New(WithServiceName(name))(next)
}

// extract the route name.
func extractRoute(uri string) string {
	return uri[1:]
}

// WithTracer is a TraceOption to inject your own trace.Tracer.
func WithTracer(tracer trace.Tracer) TraceOption {
	return func(c *traceConfig) {
		c.tracer = tracer
	}
}

// WithPropagator is a TraceOption to inject your own propagation.
func WithPropagator(p propagation.TextMapPropagator) TraceOption {
	return func(c *traceConfig) {
		c.propagator = p
	}
}

// WithServiceName is a TraceOption to inject your own serviceName.
func WithServiceName(serviceName string) TraceOption {
	return func(c *traceConfig) {
		c.serviceName = serviceName
	}
}

// WithAttributes is a TraceOption to inject your own attributes.
// Attributes are applied to the trace.Span.
func WithAttributes(attributes ...attribute.KeyValue) TraceOption {
	return func(c *traceConfig) {
		c.attributes = attributes
	}
}

// WithPathSkipper takes a collection of path patterns and adds them to the skipPaths field of the traceConfig struct.
// The skipPaths field is used to skip specific paths during tracing.
// If the provided path patterns are empty, no changes will be applied to skipPaths.
// Each path pattern is compiled into a regular expression and added to skipPaths.
// If a path pattern fails to compile, it will be skipped and not added to skipPaths.
func WithPathSkipper(paths ...string) TraceOption {
	return func(c *traceConfig) {
		if len(paths) == 0 {
			return
		}

		ps := make(skipPaths, len(paths))
		for _, path := range paths {
			if r, err := regexp.Compile(path); err == nil {
				ps = append(ps, r)
			}
		}
		c.skipPaths = ps
	}
}
